//! Some instructions are never generated by SDCC (except perhaps by way of intrinsics or
//! whatever), so here is a constraint that excludes such instructions from consideration.
//!
//! The instructions in question include `exx` and `ex af, af'` for reasons having to do with
//! interrupt handlers or something.
//!
//! Also `SP` is not loaded or modified
//!
//! Therefore, this module implements conveniences for skipping these instructions.

use crate::z80::Insn;
use crate::Constrain;
use crate::Sequence;

/// Performs static analysis making sure that instruction selection is consistent with the SDCC ABI
#[derive(Debug)]
pub struct SdccCall1Constraint<'a>(pub &'a mut Sequence<Insn>);

impl SdccCall1Constraint<'_> {
    /// builds a new `NotLive` struct.
    pub fn new<'a>(seq: &'a mut Sequence<Insn>) -> SdccCall1Constraint<'a> {
        SdccCall1Constraint::<'a>(seq)
    }

    fn check(&self, offset: usize) -> bool {
        use crate::Encode;
        let i = self.0[offset].encode()[0];

        [
            0x08, // ex af, af'
            0x31, // ld sp, ....
            0x33, // inc sp
            0x3b, // dec sp
        ]
        .contains(&i)
    }
}

impl Constrain<Insn> for SdccCall1Constraint<'_> {
    fn fixup(&mut self) {
        for i in 0..(self.0.len() - 1) {
            while self.check(i) {
                self.0.mut_at(Insn::next_opcode, i);
            }
        }
    }

    fn report(&self, offset: usize) -> Vec<String> {
        if self.check(offset) {
            vec!["disallowed in SDCC ABI".to_string()]
        } else {
            vec![]
        }
    }
}
