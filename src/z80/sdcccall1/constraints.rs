//! Some instructions are never generated by SDCC (except perhaps by way of intrinsics or
//! whatever), so here is a constraint that excludes such instructions from consideration.
//!
//! The instructions in question include `exx` and `ex af, af'` for reasons having to do with
//! interrupt handlers or something.
//!
//! Also `SP` is not loaded or modified
//!
//! Therefore, this module implements conveniences for skipping these instructions.

use crate::z80::Insn;
use crate::Constrain;

/// Performs static analysis making sure that instruction selection is consistent with the SDCC ABI
#[derive(Debug, Default)]
pub struct SdccCall1Constraint();

impl SdccCall1Constraint {
    fn check(&self, seq: &crate::Sequence<Insn>, offset: usize) -> bool {
        use crate::Encode;
        let i = seq[offset].encode()[0];

        [
            0x08, // ex af, af'
            0x31, // ld sp, ....
            0x33, // inc sp
            0x3b, // dec sp
        ]
        .contains(&i)
    }
}

impl Constrain<Insn> for SdccCall1Constraint {
    fn fixup(&self, seq: &mut crate::Sequence<Insn>) -> Option<(usize, &'static str)> {
        for i in 0..(seq.len() - 1) {
            if self.check(seq, i) {
                seq.mut_at(Insn::next_opcode, i);
                return Some((i, "disallowed in SDCC ABI"));
            }
        }
        None
    }
}
