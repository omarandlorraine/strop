# strop
[![Build Status](https://github.com/omarandlorraine/strop/workflows/Rust/badge.svg)](https://github.com/omarandlorraine/strop/actions?workflow=Rust)
[![crates.io](https://img.shields.io/crates/v/strop)](https://crates.io/crates/strop)

## Introduction

This program stochastically generates assembly language programs that compute a
given function. The idea is you give it a function to compute and specify which
registers and things to use, and strop will generate and output a pretty good
program which does the specified thing.

I abandoned [stoc](https://github.com/omarandlorraine/stoc), a similar thing
done in C, when I realized it was simply too unwieldly to work with. I needed
an excuse to learn Rust, plus I wanted a superoptimizer that could target
things other than the 6502, So, strop was born, the *st*ochastic *op*timizer,
written in *R*ust.

The basic idea is to generate code better than what traditional optimising
compilers can do. A few of the reasons why that's possible:

- we can do an exhaustive search, while optimizing compilers generally do a
  greedy ascent. That means strop will find a global maximum, instead of a
  local maximum.

- we can put things like error margins, and don't-care bits on output
  variables, which can yield more opportunity for code optimization. That's
  like saying, "oh I don't care if the program computes things 100% correctly,
  so long as it's much faster", which I bet could have some utility.

- we can add different weights to each test case. That would be like saying,
  "oh, I don't care if the program is suboptimal in the general case, so long as
  it's more optimal for these specific test cases."

- having run all the test cases, we can take some measurements such as branch
  predictability and such likes, and optimize for the same.

The way strop generates code is by running a code sequence against a set of
test cases (these may be generated by strop itself or supplied by the user).
The code is mutated and run against the test cases over and over again. When
the test cases all pass, we know the program is good. As the code is run, we
can analyse it for characteristics like speed and size, and this information
can be fed into the way we mutate or select the code sequence.

Prior work I have taken inspiration from:

- (Superoptimizer - A Look at the Smallest
  Program)[https://web.stanford.edu/class/cs343/resources/superoptimizer.pdf],
  an exhaustive search for Motorola 68020 programs.
- (GNU superopt)[https://github.com/embecosm/gnu-superopt], an exhaustive
  search over programs for many different architectures.
- (STOKE)[https://github.com/StanfordPL/stoke], a stochastic superoptimizer
  written in C++. It targets and runs on 64-bit x86 processors.

From what I have seen, both exhaustive search and stochastic search strategies
have proven useful, so strop includes both. One thing I liked about superopt is
it targets many different processors. So I have tried to make strop able to do
the same.


